----------------------------------------------------------------------
Copyright 2007-2008 Alexey Radul.
----------------------------------------------------------------------
This file is part of Test Manager.

Test Manager is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Test Manager is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Test Manager.  If not, see <http://www.gnu.org/licenses/>.
----------------------------------------------------------------------

I want to be able to write tests that look like repl sessions (there's
an example lying around somewhere).

I envision a check macro that tests the truth of a predicate and
captures the values of its arguments, thus:
(check (foo? bar baz) [message])
turns into
(let ((x foo?) (y bar) (z baz))
  (assert-true (x y z) (better-message '(foo? bar baz) x y z message)))
(the idea being that the better-message function can tell us what the
expression was, and what all the values were) (construction of the better
message can be delayed until the assertion fails)

Then I can also get my hands on a check-all macro that just spews
(check ...) around every argument form
- and a (define-each-check form ...) that does (define-test (check form)) ...

Then I can also add a general-purpose pattern matcher, or normal form
converter, or something (incl good handling of records)

----------------------------------------------------------------------

assert-match or so should be more effective than it is
(incl good handling of records)

check-* instead of assert-*?
- A fail function that always fails (but emits its message, yes)
- Should be a (check form) macro that looks into its argument properly
  and generates the right error messages
- Should be a (check-all form ...) macro that turns into (check form) ...
  (instead of define-each-test)

with-check-info macro (and function) adds extra information
to the failure display

Example failure display in SchemeUnit
--------------------
A test
... has a FAILURE
name:       check-pred
location:   (#<path:/Users/noel/programming/schematics/schemeunit/branches/v3/doc/file-test.scm> 14 6 252 22)
expression: (check-pred even? elt)
params:     (#<procedure:even?> 9)
--------------------

SchemeUnit has check-*, test-begin, test-case, test-suite
test-begin will abort the rest of the test if any internal check fails
test-case is a named version of a test-begin (apparently)
a test-suite delays test execution

"Checks look like functions, even though they are implemented as macros"
Check information has lexical scope

define-check, define-simple-check, define-binary-check macros
define-check is like define-simple-check, except that it fails
only if the fail-check macro is called inside, whereas define-simple-check
fails if the interior evaluates to #f.

----------------------------------------------------------------------

Api features
- Is it ok to write (run-test foo bar) inside of a surround definition
  if the tests are all defined to take arguments?  What use can I put
  this to?
  - I could use this for manually simulating something like quickcheck
  - Implement by making the actual run-test take any set of args, and
    applying the internal procedure.
- (in-test-group '(chain of subgroups) ...) could descend down the
  whole chain in one swoop
- (define-deep-set-up ...) could define a setup to be run before each
  test, no really, test not subgroup.
- Do the assertions want to be macros that include the actual code
  of their input expressions in their messages?
  - Should probably provide the procedural versions anyway, for, say, map
- Do I want to offer some find of (let-fixtures (binding ...)
  test-definition ...) facility (that would allow mutation of the fixtures
  internally, but restore them at every test)?
- A way to mark that certain tests or assertions are expected to fail?
  Perhaps with keyword arguments to the appropriate functions?  Grem
  sent email titled "expected failure features for test-manager"

Emacs interface:
- run-test-at-point
  - with the group's setup and teardown
- run-test-group-at-point
- run-tests-in-file
- syntax-highlight define-test
- rerun-last-test-{suite/group/single test}
- run-last-defined-{test/suite/group} ?

Problems:
- The test-runner system is in *desperate* need of refactoring.
  - Use SOS?  Portability issues?
  - Perhaps a function that returns a result object, from which 
    the results can then be printed?
  - How much do I care about this extensibility thing?

I am beginning to realise what languages I am trying to create here.
The current main focus is a language for defining test suites.  It
consists of assertions, tests, and test groups.  There is an
interesting collection of thoughts to be thought about implicitness
and explicitness.  For example, in-test-group arranges an implicit
change in the "current test group", which affects things like
define-test and possibly define-set-up, define-group-set-up, etc.  In
contrast, there is also the explict set-tg:group-set-up! and their
ilk.  The function (current-test-group) functions as a bridge between
the two worlds.

Language for defining test suites
Language for defining individual tests
Language for running tests and getting results
